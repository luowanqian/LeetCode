# LeetCode 448. Find All Numbers Disappeared in an Array

- [LeetCode 448. Find All Numbers Disappeared in an Array](#leetcode-448-find-all-numbers-disappeared-in-an-array)
  - [题目](#题目)
  - [题解1](#题解1)
  - [题解2](#题解2)

## 题目

给你一个含 `n` 个整数的数组 `nums` ，其中 `nums[i]` 在区间 `[1, n]` 内。请你找出所有在 `[1, n]` 范围内但没有出现在 `nums` 中的数字，并以数组的形式返回结果。

示例 1：

```
输入：nums = [4,3,2,7,8,2,3,1]
输出：[5,6]
```

示例 2：

```
输入：nums = [1,1]
输出：[2]
``` 

提示：

* `n == nums.length`
* `1 <= n <= 105`
* `1 <= nums[i] <= n`

**进阶**：你能在不使用额外空间且时间复杂度为 `O(n)` 的情况下解决这个问题吗? 你可以假定返回的数组不算在额外空间内。

## 题解1

代码：[solution1.cpp](solution1.cpp)

遍历数组一遍，用哈希表记录数组中出现的数字，然后遍历区间 `[1, n]`，查找哈希表是否有数字没出现过

* 空间复杂度：O(n)
* 算法复杂度：O(n)

## 题解2

代码：[solution2.cpp](solution2.cpp)

**核心思路**：由于数字范围均在 `[1, n]`，可作为数组索引，因此考虑将原数组充当哈希表

由于数字范围均在 `[1,n]` 中，我们也可以用一个长度为 `n` 的数组来代替哈希表。这一做法的空间复杂度是 `O(n)` 的。我们的目标是优化空间复杂度到 `O(1)`。

注意到 `nums` 的长度恰好也为 `n`，能否让 `nums` 充当哈希表呢？

由于 `nums` 的数字范围均在 `[1,n]` 中，我们可以利用这一范围**之外**的数字，来表达「是否存在」的含义。

具体来说，遍历 `nums`，每遇到一个数 `x`，就让 `nums[x−1]` 增加 `n`。由于 `nums` 中所有数均在 `[1,n]` 中，增加以后，这些数必然大于 `n`。最后我们遍历 `nums`，若 `nums[i]` 未大于 `n`，就说明没有遇到过数 `i+1`。这样我们就找到了缺失的数字。

注意，当我们遍历到某个位置时，其中的数可能已经被增加过，因此需要对 `n` 取模来还原出它本来的值。