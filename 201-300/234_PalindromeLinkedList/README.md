# LeetCode 234. Palindrome Linked List

- [LeetCode 234. Palindrome Linked List](#leetcode-234-palindrome-linked-list)
  - [题目](#题目)
  - [题解1](#题解1)
  - [题解2](#题解2)

## 题目

给你一个单链表的头节点 `head` ，请你判断该链表是否为回文链表。如果是，返回 `true` ；否则，返回 `false` 。

示例1:

```
1 -> 2 -> 2 -> 1

输入：head = [1,2,2,1]
输出：true
```

示例2:

```
1 -> 2

输入：head = [1,2]
输出：false
```

提示：

* 链表中节点数目在范围 `[1, 10^5]` 内

* `0 <= Node.val <= 9`

进阶：你能否用 `O(n)` 时间复杂度和 `O(1)` 空间复杂度解决此题？

## 题解1

代码：[solution1.cpp](solution1.cpp)

遍历链表，然后把链表所有元素复制到一个数组中，然后用双指针法判断是否为回文

## 题解2

代码：[solution2.cpp](solution2.cpp)

主要思路：将链表一分为二，修改前半部分链表的连接方向，两个指针分别指向两个链表的head

1. 如果是奇数节点链表，例如链表 `1 -> 2 -> 3 -> 2 -> 1`，将该链表一分为二，可得

```
     p1      p2
     |       |
1 <- 2  3 -> 2 -> 1 
```

2. 如果是偶数节点链表，例如链表 `1 -> 2 -> 2 -> 1`，将链表一分为二，可得

```
     p1 p2
     |  |
1 <- 2  2 -> 1 
```

要实现这个切分，首先要找到链表中间节点，这个可以通过快慢指针实现，初始慢指针指向head，快指针指向head->next。慢指针每次移动一个节点，快指针就移动两个节点，直到快指针为nullptr或者其下一个节点为nullptr即可停止遍历。此外，慢指针移动时，将慢指针节点next指向其上一个节点，以此达到修改前半部分链表方向作用

切分完后，分别遍历切分出的两个链表，即可实现回文链表判断