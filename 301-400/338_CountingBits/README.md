# LeetCode 338. Counting Bits

- [LeetCode 338. Counting Bits](#leetcode-338-counting-bits)
  - [题目](#题目)
  - [题解1](#题解1)
  - [题解2](#题解2)

## 题目

给你一个整数 `n` ，对于 `0 <= i <= n` 中的每个 `i` ，计算其二进制表示中 `1` 的个数 ，返回一个长度为 `n + 1` 的数组 `ans` 作为答案。

示例 1：

```
输入：n = 2
输出：[0,1,1]
解释：
0 --> 0
1 --> 1
2 --> 10
```

示例 2：

```
输入：n = 5
输出：[0,1,1,2,1,2]
解释：
0 --> 0
1 --> 1
2 --> 10
3 --> 11
4 --> 100
5 --> 101
``` 

提示：

`0 <= n <= 10^5`
 

进阶：

很容易就能实现时间复杂度为 `O(n log n)` 的解决方案，你可以在线性时间复杂度 `O(n)` 内用一趟扫描解决此问题吗？

你能不使用任何内置函数解决此问题吗？（如，C++ 中的 `__builtin_popcount` ）

## 题解1

代码：[solution1.cpp](solution1.cpp)

思路：遍历每个数字，然后判断该数字二进制表示中1的个数 -- 通过逻辑与`&`和左移操作进行判断

```c++
int count = 0;
int mask = 0x1;
for (int i = 1; i < sizeof(int)*8; i++) {
    int tmp = n & mask;
    if (tmp != 0) {
        count++;
    }
    mask = mask << 1;
}
```

## 题解2

代码：[solution2.cpp](solution2.cpp)

利用 `Brian Kernighan` 算法，可以在一定程度上进一步提升计算速度。`Brian Kernighan` 算法的原理是：对于任意整数 `x`，令 `x = x & (x−1)`，该运算将 `x` 的二进制表示的最后一个 `1` 变成 `0`。因此，对 `x` 重复该操作，直到 `x` 变成 `0`，则操作次数即为 `x` 的 一比特数